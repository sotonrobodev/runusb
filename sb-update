#!/usr/bin/env python3

import argparse
import os
import pathlib
import subprocess
import tempfile
import shutil
import logging

from typing import List

UPDATE_FILENAME = 'update.tar.xz'
SB_DEBS = '/sb-debs'
LOG_FILE = 'update.log'


def argument_parser():
    parser = argparse.ArgumentParser(
        description="Automatically run from mountpoints with .autorun",
    )

    parser.add_argument(
        'path',
        help="path to usb drive",
        action='store',
    )
    return parser


def rebuild_apt_repo():
    logging.debug("Rebuilding apt repo")
    working_dir = os.getcwd()
    os.chdir(SB_DEBS)
    with open('Packages', 'wb') as packages:
        subprocess.check_call(['dpkg-scanpackages', '.', '/dev/null'], stdout=packages)
    subprocess.check_call(['xz', '-f', '-3', 'Packages'])
    os.chdir(working_dir)


def update_and_upgrade():
    logging.debug("Updating Repos")
    subprocess.check_call(['apt', 'update', '-y'], stdout=subprocess.DEVNULL)
    logging.debug(subprocess.check_output(['apt', 'list', '--upgradable']))

    logging.debug("Performing update")
    subprocess.check_call(['apt', 'upgrade', '-y'], stdout=subprocess.DEVNULL)


def validate_deb(deb_path: pathlib.Path) -> None:
    """
    Validate that the given path is indeed a debian package.

    Raises ``ValueError`` if the package is not valid.
    """
    check_deb = subprocess.call(
        ['dpkg', '--info', str(deb_path)],
        stdout=subprocess.DEVNULL,
    )

    if check_deb != 0:
        raise ValueError("file {} is not a deb file!".format(deb_path))


def _extract_debs(
    update_file: pathlib.Path,
    working_dir: tempfile.TemporaryDirectory,
) -> List[pathlib.Path]:

    subprocess.check_call(
        [
            'tar',
            '--extract',
            '--xz',
            '--file', str(update_file),
        ],
        cwd=str(working_dir),
    )

    return list(working_dir.glob("*.deb"))


def add_debs_to_local_repo_from(update_file: pathlib.Path) -> None:
    """
    Given the path to an xz-compressed tarball, copy any .deb files to the
    ``SB_DEBS`` directory.
    """

    with tempfile.TemporaryDirectory(prefix='updates-') as updates_dir:
        found_debs = _extract_debs(update_file, pathlib.Path(updates_dir))

        if not found_debs:
            raise FileNotFoundError(
                "Failed to find deb files in {}, exiting".format(update_file),
            )

        logging.debug("Found {} potential packages".format(len(found_debs)))

        # Check that all the debs are valid
        for deb_path in found_debs:
            validate_deb(deb_path)

        # Add all the debs to the repo directory.
        # Note that we do this _separately_ after the checking, so that we can
        # be somewhat confident that either all the debs that were in the
        # update are all in the repo or none are.
        for deb_path in found_debs:
            logging.debug("Adding {} to internal repo".format(
                os.path.basename(deb_path),
            ))
            shutil.copy(deb_path, SB_DEBS)


def main():
    options = argument_parser().parse_args()
    logging.basicConfig(
        level=logging.DEBUG,
        handlers=[
            logging.FileHandler(os.path.join(options.path, LOG_FILE)),
            logging.StreamHandler()
        ]
    )
    update_file = pathlib.Path(os.path.join(options.path, UPDATE_FILENAME))

    logging.info("Starting updates from {}".format(update_file))
    add_debs_to_local_repo_from(update_file)

    update_file.unlink()

    rebuild_apt_repo()
    update_and_upgrade()

    logging.info("Upgrade complete, cleaning up.")

    logging.info("Rebooting.")
    subprocess.check_call(["reboot"])


if __name__ == '__main__':
    main()
